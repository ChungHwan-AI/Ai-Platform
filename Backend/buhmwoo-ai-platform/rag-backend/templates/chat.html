<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>RAG 챗봇</title>
    <!-- 기본적인 레이아웃과 색상을 정의하여 ChatGPT와 유사한 화면을 구성함 -->
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 0;
        /* 전체 화면을 밝은 그라디언트로 채워 포근한 분위기를 만들고 중앙 집중형 레이아웃을 구성함 */
        background: linear-gradient(160deg, #f5f7ff 0%, #f1f5f9 45%, #ffffff 100%);
        color: #1f1f1f;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 24px 16px;
        background: transparent;
        color: #1f2937;
        text-align: center;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.5rem, 2.4vw, 2rem);
        font-weight: 700;
      }

      header p {
        margin-top: 8px;
        font-size: 0.95rem;
        opacity: 0.75;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 16px 32px;
        gap: 18px;
      }

      .chat-container {
        flex: 1;
        width: min(100%, 920px);
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(12px);
        border-radius: 24px;
        box-shadow: 0 22px 60px rgba(15, 23, 42, 0.12); 
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .messages {
        flex: 1;
        overflow-y: auto;
        padding: 32px 28px 28px;
        display: flex;
        flex-direction: column;
        gap: 22px;
        align-items: center; /* 모든 메시지를 기본적으로 가운데 정렬해 중앙 집중형 UI를 구현 */
        background: linear-gradient(180deg, rgba(241, 245, 249, 0.85), rgba(255, 255, 255, 0.95));
      }

      .message {
        width: min(100%, 720px);        
        display: flex;
        gap: 16px;
        align-items: flex-start;
        transition: transform 0.2s ease;
      }

      .message.assistant {
        align-self: flex-start; /* 어시스턴트 메시지는 왼쪽에 붙여 자연스러운 대화를 연출 */
      }

      .message.user {
        align-self: flex-end; /* 사용자 메시지는 오른쪽 정렬 */
        flex-direction: row-reverse; /* 사용자 아바타를 오른쪽에 배치 */
      }

      .message:hover {
        transform: translateY(-1px);        
      }

      .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-weight: 700;
        color: white;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.15);        
      }

      .avatar.user {
        background: linear-gradient(135deg, #22c55e, #16a34a);
      }

      .avatar.assistant {
        background: linear-gradient(135deg, #3f5efb, #5ca9fb);
      }

      .bubble {
        flex: 1;
        background: white;
        border-radius: 20px;
        padding: 18px 20px;
        box-shadow: 0 16px 36px rgba(15, 23, 42, 0.12);
        line-height: 1.6;
        font-size: 0.98rem;
      }

      .message.user .bubble {
        /* 사용자 메시지는 ChatGPT와 유사하게 말풍선 색상을 살짝 다르게 처리 */
        background: linear-gradient(135deg, #dbeafe, #f8fafc);
      }

      .bubble h3 {
        margin-top: 12px;
        margin-bottom: 6px;
        font-size: 1.05rem;
      }

      .thinking {
        position: relative;
      }

      .thinking .dots::after {
        content: "";
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #3f5efb;
        box-shadow: 12px 0 0 #5ca9fb, -12px 0 0 #7aa2ff;
        display: inline-block;
        animation: blink 1s infinite ease-in-out;
      }

      @keyframes blink {
        0%,
        80%,
        100% {
          box-shadow: 12px 0 0 #5ca9fb, -12px 0 0 #7aa2ff;
          opacity: 0.35;
        }
        40% {
          box-shadow: 12px 0 0 #5ca9fb, -12px 0 0 #7aa2ff;
          opacity: 1;
        }
      }
            
      .bubble ul {
        padding-left: 18px;
      }

      .bubble code {
        background: rgba(15, 23, 42, 0.06);
        border-radius: 6px;
        padding: 2px 6px;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.85rem;
      }

      .bubble pre {
        background: rgba(15, 23, 42, 0.08);
        padding: 12px;
        border-radius: 10px;
        overflow-x: auto;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.9rem;
      }

      .matches {
        margin-top: 16px;
        border-top: 1px solid rgba(15, 23, 42, 0.08);
        padding-top: 12px;
        font-size: 0.85rem;
        color: #475569;
      }

      .matches h4 {
        margin: 0 0 8px;
        font-size: 0.9rem;
        font-weight: 600;
      }

      .matches ul {
        padding-left: 18px;
        margin: 0;
        display: grid;
        gap: 6px;
      }

      .input-area {
        padding: 20px 18px 24px;
        background: rgba(248, 250, 252, 0.96);
        border-top: 1px solid rgba(148, 163, 184, 0.18);
      }

      form {
        display: flex;
        gap: 12px;
        width: min(100%, 920px);
        margin: 0 auto;
      }

      textarea {
        flex: 1;
        resize: none;
        min-height: 88px;
        border-radius: 16px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 16px 18px;
        font-size: 1rem;
        line-height: 1.56;
        transition: border 0.2s ease, box-shadow 0.2s ease;
        background: rgba(255, 255, 255, 0.92);
      }

      textarea:focus {
        outline: none;
        border-color: #3f5efb;
        box-shadow: 0 0 0 3px rgba(63, 94, 251, 0.18);
      }

      button {
        border: none;
        border-radius: 16px;
        padding: 0 28px;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(135deg, #3f5efb, #5ca9fb);
        color: white;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.65;
        box-shadow: none;
        transform: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(63, 94, 251, 0.28);
      }

      .meta-options {
        width: min(100%, 920px);
        margin: 0 auto;
        display: flex;
        gap: 16px;
        font-size: 0.85rem;
        color: #475569;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap; /* 좁은 화면에서도 옵션이 자연스럽게 줄바꿈되도록 함 */        
      }

      .meta-options label {
        display: flex;
        flex-direction: column-reverse; /* 최근 메시지를 항상 상단에 배치해 답변을 바로 확인할 수 있도록 함 */
        gap: 6px;
        background: rgba(255, 255, 255, 0.72);
        padding: 10px 14px;
        border-radius: 14px;
        box-shadow: 0 10px 28px rgba(15, 23, 42, 0.08);
      }

      .meta-options input {
        border-radius: 12px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.95);
      }

      @media (max-width: 768px) {
        form {
          flex-direction: column;
        }

        button {
          width: 100%;
          min-height: 48px;
        }

        .chat-container {
          border-radius: 18px;
        }

        .messages {
          padding: 24px 16px 16px;
        }

        .message {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>원아스크 RAG 챗봇</h1>
      <p>벡터DB에 등록된 문서를 바탕으로 GPT가 답변하는 인터페이스입니다.</p>
    </header>
    <main>
      <div class="chat-container">
        <div id="messages" class="messages">
          <!-- 초기 안내 메시지를 통해 사용자가 입력 방법을 이해하도록 돕는다 -->
          <div class="message assistant">
            <div class="avatar assistant">AI</div>
            <div class="bubble">
              <strong>안녕하세요!</strong><br />
              사내 문서를 기반으로 궁금한 점을 질문해 주세요. 필요한 경우 아래 옵션에서 특정 문서 ID나 검색 범위를 지정할 수도 있습니다.
            </div>
          </div>
        </div>
        <div class="input-area">
          <form id="chat-form">
            <textarea
              id="question"
              placeholder="예) 최근 생산 계획의 핵심 요약을 알려줘"
              required
            ></textarea>
            <button type="submit">전송</button>
          </form>
        </div>
      </div>
      <div class="meta-options">
        <!-- docId 와 top_k 를 사용자가 조정할 수 있도록 간단한 옵션 입력란을 제공함 -->
        <label>
          문서 ID (선택)
          <input type="text" id="docId" placeholder="123e4567-e89b-12d3-a456-426614174000" />
        </label>
        <label>
          검색 청크 개수
          <input type="number" id="topK" min="1" max="20" value="4" />
        </label>
      </div>
    </main>

    <script>
      // 채팅 영역 요소를 캐싱하여 메시지를 빠르게 추가할 수 있도록 함
      const messagesEl = document.getElementById("messages");
      const formEl = document.getElementById("chat-form");
      const questionEl = document.getElementById("question");
      const docIdEl = document.getElementById("docId");
      const topKEl = document.getElementById("topK");

      // 간단한 마크다운 헤더/리스트를 HTML 구조로 치환하는 함수
      function renderMarkdown(text) {
        // 헤더 변환
        let html = text
          .replace(/^###\s?(.*)$/gim, "<h3>$1</h3>")
          .replace(/^##\s?(.*)$/gim, "<h3>$1</h3>")
          .replace(/^#\s?(.*)$/gim, "<h2>$1</h2>");
        // 순서 없는 리스트 변환
        html = html.replace(/^(?:-\s+.+(?:\n|$))+?/gim, (match) => {
          const items = match
            .trim()
            .split(/\n/)
            .map((line) => line.replace(/^-\s+/, "").trim())
            .map((line) => `<li>${line}</li>`) // 각 항목을 li 로 감싸 가독성을 높임
            .join("");
          return `<ul>${items}</ul>`;
        });
        // 줄바꿈을 <br> 로 치환하여 단락 간격을 유지함
        html = html.replace(/\n{2,}/g, "</p><p>").replace(/\n/g, "<br>");
        return `<p>${html}</p>`;
      }

      // 메시지 DOM 노드를 생성하는 헬퍼 함수
      function appendMessage(role, content, matchesHtml = "") {
        const wrapper = document.createElement("div");
        wrapper.className = `message ${role}`; // 역할에 따라 정렬 스타일을 달리 적용하기 위해 클래스명을 동적으로 지정함

        const avatar = document.createElement("div");
        avatar.className = `avatar ${role}`;
        avatar.textContent = role === "user" ? "ME" : "AI";

        const bubble = document.createElement("div");
        bubble.className = "bubble";
        bubble.innerHTML = content;

        if (matchesHtml) {
          const matchesSection = document.createElement("div");
          matchesSection.className = "matches";
          matchesSection.innerHTML = matchesHtml;
          bubble.appendChild(matchesSection);
        }

        wrapper.appendChild(avatar);
        wrapper.appendChild(bubble);
        messagesEl.appendChild(wrapper);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      // 추천 근거 목록을 HTML 리스트로 만드는 함수
      function buildMatches(matches) {
        if (!matches || matches.length === 0) {
          return "";
        }
        const items = matches
          .map((match) => {
            const pageText = match.page != null ? ` (페이지 ${match.page})` : "";
            const preview = match.preview || match.content || "(미리보기 없음)";
            return `<li><strong>${match.reference}</strong> · ${match.source}${pageText}<br>${preview}</li>`;
          })
          .join("");
        return `<h4>참고한 근거</h4><ul>${items}</ul>`;
      }

      // 폼 제출 시 RAG 백엔드에 질의하는 메인 이벤트 핸들러
      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();

        const question = questionEl.value.trim();
        if (!question) {
          return;
        }

        appendMessage("user", question.replace(/\n/g, "<br>"));
        questionEl.value = "";

        const thinking = document.createElement("div");
        thinking.className = "message assistant"; // 어시스턴트 메시지 형식을 재사용해 로딩 상태도 동일한 위치에 배치함
        thinking.innerHTML = `
          <div class="avatar assistant">AI</div>
          <div class="bubble">답변을 생성하는 중입니다...</div>
        `;
        messagesEl.appendChild(thinking);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          const payload = {
            question,
            top_k: Number(topKEl.value) || 4,
          };
          if (docIdEl.value.trim()) {
            payload.doc_id = docIdEl.value.trim();
          }

          const response = await fetch("/query", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          const data = await response.json();

          thinking.remove();

          if (!response.ok) {
            const detail = data?.detail || "알 수 없는 오류가 발생했습니다.";
            appendMessage(
              "assistant",
              `<strong>요청이 실패했습니다.</strong><br>${detail}`
            );
            return;
          }

          const answerHtml = renderMarkdown(data.answer || "(응답이 비어 있습니다)");
          const matchesHtml = buildMatches(data.matches || []);
          appendMessage("assistant", answerHtml, matchesHtml);
        } catch (error) {
          thinking.remove();
          appendMessage(
            "assistant",
            `<strong>네트워크 오류가 발생했습니다.</strong><br>${error}`
          );
        }
      });
    </script>
  </body>
</html>